# encoding=utf-8

'''
经题，后悔没有仔细想，也是没想到面试官会问这么麻烦。给你一个8*8的矩阵，一个起始点，一个终点，和k值，求从起始点到终点走k步有多少种走法。这里和我们平时刷题的搜索题不同，这里所有点都可以重复走。我愣了一小会儿，说用bfs搜k层看有多少种结果。面试官不满意时间复杂度和空间复杂度太高，要我改进，我说剪枝。面试官还是不满意，说这个其实没什么改进，然后提示下说用其他搜索可以省空间，于是就写了个dfs。然后时间久到了，面试官说你已经在找到答案的方向上了，说时间上还可以提高很多。说完这话我就觉得估计这轮也够呛了。。。吐血，我回家之后也没想到这题有啥好方法，如果没记错的话貌似面试官要求线性复杂度，这打死我也想不出来。。。



 我先用BFS然后followup 用DP做的


 8*8的棋盘 走K步从一个点走到另一个点有多少不同路径，之前在地里看到过但下面的都不对，先写了个dfs， 然后说简化，我说两头dfs， 然后说再简化，


 然后经他提示用dp做出来了， 思路是第K步走到一个格子一共有多少不同路径， 那么K+1步走到他周围八个点就是多少路径，解法类似Game of life开个buff数组


从一个格子走到另一个格子走K部有多少不同的走法 哦对了 上下左右对角线都可以走 所以每次有八步

 想了半天终于稍微想通了一点楼主说第二题DP的解法了。LZ NB！

 那假如求从A点[0,0] 走 3步 到B点[0,1]的路径数 ,  那从A到B回到A再到B, 这条3步的路线也算在内吗？
 中间已经到过B的话，这条路线要不要当做是2步的路线排除掉呢。

  算的 你不要想得太复杂 K = 1的时候只有起始点周围是1 然后K=2的时候就扩展下去

      算的 你不要想得太复杂 K = 1的时候只有起始点周围是1 然后K=2的时候就扩展下去

  -google 1point3acres
  明白了 那真是跟game of life一样的，相当于把game of life迭代K遍

 http://www.1point3acres.com/bbs/thread-176559-1-1.html
'''


'''
经题，后悔没有仔细想，也是没想到面试官会问这么麻烦。给你一个8*8的矩阵，一个起始点，一个终点，和k值，求从起始点到终点走k步有多少种走法。这里和我们平时刷题的搜索题不同，这里所有点都可以重复走。我愣了一小会儿，说用bfs搜k层看有多少种结果。面试官不满意时间复杂度和空间复杂度太高，要我改进，我说剪枝。面试官还是不满意，说这个其实没什么改进，然后提示下说用其他搜索可以省空间，于是就写了个dfs。然后时间久到了，面试官说你已经在找到答案的方向上了，说时间上还可以提高很多。说完这话我就觉得估计这轮也够呛了。。。吐血，我回家之后也没想到这题有啥好方法，如果没记错的话貌似面试官要求线性复杂度，这打死我也想不出来。。。



 我先用BFS然后followup 用DP做的


 8*8的棋盘 走K步从一个点走到另一个点有多少不同路径，之前在地里看到过但下面的都不对，先写了个dfs， 然后说简化，我说两头dfs， 然后说再简化，


 然后经他提示用dp做出来了， 思路是第K步走到一个格子一共有多少不同路径， 那么K+1步走到他周围八个点就是多少路径，解法类似Game of life开个buff数组


从一个格子走到另一个格子走K部有多少不同的走法 哦对了 上下左右对角线都可以走 所以每次有八步

 想了半天终于稍微想通了一点楼主说第二题DP的解法了。LZ NB！

 那假如求从A点[0,0] 走 3步 到B点[0,1]的路径数 ,  那从A到B回到A再到B, 这条3步的路线也算在内吗？
 中间已经到过B的话，这条路线要不要当做是2步的路线排除掉呢。

  算的 你不要想得太复杂 K = 1的时候只有起始点周围是1 然后K=2的时候就扩展下去

      算的 你不要想得太复杂 K = 1的时候只有起始点周围是1 然后K=2的时候就扩展下去

  -google 1point3acres
  明白了 那真是跟game of life一样的，相当于把game of life迭代K遍

 http://www.1point3acres.com/bbs/thread-176559-1-1.html
'''

class Solution:
    def solve(self, k, start, end):
        board = [[0]*8 for i in range(8)]
        board[start[0]][start[1]] = 1
        tempBoard = {}
        for x in range(k-1):
            for i in range(8):
                for j in range(8):
                    tempBoard[(i, j)] = sum( board[x][y] for x in [i-1, i, i+1] for y in [j-1, j, j+1] if (i!=x or j!=y) and (0<=x<8 and 0<=y<8))
            for x,y in tempBoard:  board[x][y] = tempBoard[(x, y)]
            tempBoard = {}
        return board[end[0]][end[1]]

s = Solution()
print s.solve(3, [1, 0], [2, 0])
print s.solve(3, [1, 0], [1, 0])

